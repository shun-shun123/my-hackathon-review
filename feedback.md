# 2018HackU
## 自分の技術スタック
* Kotlin(android)
* Java(android)
* C++(openFrameworks)
* Python

* 「サーバにOSインストールする」っていうこと自体あんまり分かってないレベル
* 「Docker？？」
* 「うーん、正直サーバは本当に無知すぎてあまり何も言えないですねぇ…」
* DBに関する知識もほぼ皆無

## 作ったもの
作品名: PastPass

作品概要
私たちは、Suicaなどの交通系ICカードを読み取り、その履歴データを使ってメディアアートを描画する作品を作りました。

まず、交通系ICカードを読み取ることができるAndroidアプリを開発しました。このアプリを使ってICカード内の利用履歴データを読み取り、次にこの履歴データをGoogleAppsScriptで構築したサーバにJSON形式で送信します。このJSONデータをopenFrameworksに送り、そのデータを使ってインタラクティブな映像を描画します

## 使用技術
* Kotlin 
* GAS
* C++


## よかった点
* 技術的にニッチな部分への挑戦(NFCカードのデータ読み取り)
* 情報系の知識の応用(ビットシフトとか論理演算とか)
* 持ってる武器の発展で作れた

## 改善点
* API仕様書なんて一切作ってなかった。
* 自然言語ベースの仕様だったので、Slackがカオス
* クラスとか理解してなかったからコードもカオス

## 改善案
当時の知識・技術力だとかなり難しいけど、サーバに送るデータ形式とかJSONの構造とかは文書ベースで定義して共有しておくべきだった。(当時APIとかなんのことかさっぱりやったし、HTTP通信自体ほとんど実装したことなかったけど、、)

# 2018MashUp
後日記載

# 2019Unityハッカソン
後日記載

# 2019HackU
## 自分の技術スタック
* Kotlin(android)
* C
* C++(openFrameworks)
* Java(android)
* Python/Flask
* Unity/C#

## 作ったもの
AR-SNSアプリ

## 使用技術
* フロント
    * Unity
    * Zenject
    * ARFoundation
    * git
    * OpenWeatherAPI
    * 国土地理院API
* バックエンド
    * Python
    * Flask
    * MongoDB
    * Go(ハッカソン後書き直し)
    * Echo(ハッカソン後書き直し)
    * MySQL(ハッカソン後書き直し)
    * git
    * heroku

## よかった点
UMLを事前に書いておいたおかげで、フロントの実装は数段楽になった。Zenjectを使っていたので、初期化処理など考慮せずともinstallerをおくだけで解決。共同開発にはよかった。UI/UX実装のUnityエンジニアと機能面実装のUnityエンジニア(自分)と、フロントのタスクは綺麗に分けることができてた。プロダクトの方向性を決めるMTGで、妥協せずしっかり話し合って、世界観から共通認識を持って開発に取り組めたことは、結果としてプロダクトの完成度を高めたし、デザイナーのイメージとすり合わせやすくなった。

## 改善点
サーバサイドの仕様がガバガバのまま進めてしまった。後々フロントと接続する時にモデルクラスをほとんど書き直したりとか、サーバサイドの仕様に対してフロントが密結合していたため、APIのかきなおしするたびにフロントの書き直しが入った。プロダクト的にDBはにくるデータの形式は変動しにくいものなので、MongoDBじゃなくてRDBを採用するべきだった。プロダクトのクリティカルセクションを把握しておくべきだった。バックエンドの実装が終わらないとフロントが繋げないという部分が最終的に発覚して最後の最後で詰め込み実装になった。

## 改善案
* API仕様は早めにfixさせる
* それでも仕様は変わるのでAPIといかに疎結合な実装にするか
* DBの採用は興味ではなく、プロダクトの性質・送られてくるデータを考慮して考える
* プロジェクト全体のクリティカルセクションを把握して、そこに人員をさく（今回ならサーバサイド）

# 2019HackBowl
## 自分の技術スタック
* Kotlin(android)
* C
* C++(openFrameworks)
* Java(android)
* Python/Flask
* Unity/C#/Zenject/ARFoundation
* Go/Echo/Gorm
* MySQL
* MongoDB
* Swift(iOS)

## 作ったもの
* アイディアをメモして、その内容を自然言語解析し、実装に関連しそうなサイトを提示する
* 事前に登録されたキーワードに該当する記事を毎日提示し、達成したらユーザの経験値に加算しレベルアップする

上記二つの機能を持ったスマホアプリ(iOS)

## 使用技術
* フロント
    * Swift(iOS)
* バックエンド
    * Go/Echo/Gorm/goquery
    * MySQL
    * Dcoker
    * Kubernetes
    * Terraform
    * git
    * Cloud Natural LanguageAPI
    * Google Custom Search API
    * GOO 形態素解析API

## よかった点
バックエンドは開発環境にdockerを使っていたため、二人で開発する際も互いのPCで問題なく開発に移れた。(ここのコスト削減はかなりデカかったと思う。デプロイの時も簡潔にできた)。サービスアーキテクチャとしてマイクロサービスを採用して、機能一つごとにAPIとDBをそれぞれ用意して開発したため、先にメモを解析してサイトを提示する機能のためのAPIを完成させて、フロントがそちらに集中して開発できるようなフローが作れていた。バグの解消の時もAPIは分離して開発しているので、どこを見ればいいかが早く判断できるようになった。どちらか片方の本番環境を停止していても、片方のAPIを使って開発もできるので、その点も開発のイテレーションを早めることができていたと思う。

## 改善点
発表に関して、どういった問題点に着目し、どういったペルソナを想定し、自分たちのプロダクトがどのように使われることで、どのように問題を解決するかという論理的な説明のフローが明確ではなかったため、上手く審査員に伝わらなかった。ペルソナと問題点の解像度をもっと高く考えるべきだった。
開発に関しては、タスク管理、連絡など全てをSlackで行っていたため、Slackがカオスな状態になっていた。4人のチームでも追い込みの時のメッセ量は莫大になるため、追いきれない部分がある。大事なタスクや連絡を見落としてしまうこともあったため、タスク管理は他のツールを使用するべきだった。Redmineとか使って見てもいいかも。フロントで特にあったが、コンフリクトが起きないかをメッセベースで確認しあって開発していたため、どこどこのコードを今からいじりますと相手からの返答がないと実装できない状態があった。これもタスク管理、タスク分配の観点になるが、もっと効率良く開発できたはず。デザイナーがいないチームだったため、UI/UXがかなりずさんな部分もある。サーバサイドのチームはインフラと実装で役割分担していてそれ自体は上手くいっていたが、デプロイが完全自動化されていないため、デプロイ担当がいないと本番環境にあげることができない状態だった。自分もデプロイできるような仕組みがあるとよりよかったかも。

## 改善案
* 発表は5分だけだったので、もっと絞って確実に一点を伝えるという方が良かったかも
* 前提条件はいう必要なかった(テーマの確認とか)
* 問題設定、ペルソナ、解決案の解像度が低かった。もっと高い解像度で作っていれば軸のしっかりしたプロダクトになったと思う
* タスク管理はハッカソンだけでなくチーム開発のマストで最適化する部分。ツールの導入が根本的な解決になるかわからないけど、とにかくSlackの様々なチャンネルでメッセベースでやってしまうより、どこかで一元管理した方が効率的だと思う
* コンフリクトしないかの事前確認で作業が中断されてしまうこともあるので、様々な開発環境でどのような共同開発がベターなのか、プロジェクト単位でも事前に考えておくべきだった。(2019HackUのフロントみたいにデザイン/機能面と割り切って考えてもいいかも。ただしあれはフロントがUnityだったから成立した感じもある。基本シーンごとに開発がベターなのでは)

# 現在の自分の技術スタック
* Kotlin(android)
* C
* C++(openFrameworks)
* Java(android)
* Python/Flask
* Unity/C#/Zenject/ARFoundation
* Go/Echo/Gorm
* MySQL
* MongoDB
* Swift(iOS)
* Docker<-New!